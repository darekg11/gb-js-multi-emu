import CPU from "./components/cpu";
import Memory from "./components/memory";
import Cartridge from "./components/cartridge";

const DMG_BIOS = [
    0x31, // LD SP, nn - initializing STACK -> LD SP, 0xFFFE
    0xFE, // n
    0xFF, // n + 1
    0xAF, // XOR A A - setting A Register to 0
    0x21, // LD HL, nn - LD HL, 0x9FFF
    0xFF, // LD
    0x9F, // LD
    0x32, // LD (HL -), A -> Load to [HL] a value of reg A which is 0 and decrease HL
    0xCB, // CB SWITCH
    0x7C, // BIT 7H, sets zero flag is true
    0x20, // JR NZ, n
    0xFB, // address to jump -> this affectively should jump back to 0x0007 aka  LD (HL -) A looping it back up until all of VRAM (0x8000 - 0x9FFF) is cleared
    0x21, // LD HL, nn -> LD HL, 0xFF26 FF26 is register responsible for Sound ON / OFF -- AUDIO DEVICE INIT START (turns on device and write some basic info)
    0x26,
    0xFF,
    0x0E, // LOAD TO REG C, NEXT MEMORY CELL LD C, 0x11
    0x11, 
    0x3E, // LOAD TO REG A, NEXT MEMORY CELL LD A, 0x80
    0x80,
    0x32, // LD (HL -), A and decrement HL -> LOAD 0xFF26, 0x80 - enabling sound everywhere
    0xE2, // LD (C), A but it's load HIGH so 0xFF00 + C = 0xFF11 -> LD 0xFF11 0x80, LOAD x80 to Sound Mode 1 register, sound length, wave pattern
    0x0C, // INC C -> 0x12
    0x3E, // LOAD A, n so LOAD A, 0xF3
    0xF3, 
    0xE2, // LD (C), A but it's load HIGH so 0xFF00 + C = 0xFF12 -> LD 0xFF12 0xF3, LOAD 0xF3 to Sound Mode 1 register, Envelope
    0x32, // LD (HL -), A and decrement HL -> LOAD 0xFF25, 0xF3 - Selection of Sound output terminal (R/W)
    0x3E, // LOAD A, n so LOAD A, 0x77
    0x77,
    0x77, // LD (HL), A LD 0xFF24 0x77 Channel control / ON-OFF / Volume (R/W) -- AUDIO DEVICE INIT END
    0x3E, // LD A, 0xFC
    0xFC,

    0xE0,
    0x47, 0x11, 0x04, 0x01, 0x21, 0x10, 0x80, 0x1A, 0xCD, 0x95, 0x00, 0xCD, 0x96, 0x00, 0x13, 0x7B,
    0xFE, 0x34, 0x20, 0xF3, 0x11, 0xD8, 0x00, 0x06, 0x08, 0x1A, 0x13, 0x22, 0x23, 0x05, 0x20, 0xF9,
    0x3E, 0x19, 0xEA, 0x10, 0x99, 0x21, 0x2F, 0x99, 0x0E, 0x0C, 0x3D, 0x28, 0x08, 0x32, 0x0D, 0x20,
    0xF9, 0x2E, 0x0F, 0x18, 0xF3, 0x67, 0x3E, 0x64, 0x57, 0xE0, 0x42, 0x3E, 0x91, 0xE0, 0x40, 0x04,
    0x1E, 0x02, 0x0E, 0x0C, 0xF0, 0x44, 0xFE, 0x90, 0x20, 0xFA, 0x0D, 0x20, 0xF7, 0x1D, 0x20, 0xF2,
    0x0E, 0x13, 0x24, 0x7C, 0x1E, 0x83, 0xFE, 0x62, 0x28, 0x06, 0x1E, 0xC1, 0xFE, 0x64, 0x20, 0x06,
    0x7B, 0xE2, 0x0C, 0x3E, 0x87, 0xE2, 0xF0, 0x42, 0x90, 0xE0, 0x42, 0x15, 0x20, 0xD2, 0x05, 0x20,
    0x4F, 0x16, 0x20, 0x18, 0xCB, 0x4F, 0x06, 0x04, 0xC5, 0xCB, 0x11, 0x17, 0xC1, 0xCB, 0x11, 0x17,
    0x05, 0x20, 0xF5, 0x22, 0x23, 0x22, 0x23, 0xC9, 0xCE, 0xED, 0x66, 0x66, 0xCC, 0x0D, 0x00, 0x0B,
    0x03, 0x73, 0x00, 0x83, 0x00, 0x0C, 0x00, 0x0D, 0x00, 0x08, 0x11, 0x1F, 0x88, 0x89, 0x00, 0x0E,
    0xDC, 0xCC, 0x6E, 0xE6, 0xDD, 0xDD, 0xD9, 0x99, 0xBB, 0xBB, 0x67, 0x63, 0x6E, 0x0E, 0xEC, 0xCC,
    0xDD, 0xDC, 0x99, 0x9F, 0xBB, 0xB9, 0x33, 0x3E, 0x3C, 0x42, 0xB9, 0xA5, 0xB9, 0xA5, 0x42, 0x3C,
    0x21, 0x04, 0x01, 0x11, 0xA8, 0x00, 0x1A, 0x13, 0xBE, 0x20, 0xFE, 0x23, 0x7D, 0xFE, 0x34, 0x20,
    0xF5, 0x06, 0x19, 0x78, 0x86, 0x23, 0x05, 0x20, 0xFB, 0x86, 0x20, 0xFE, 0x3E, 0x01, 0xE0, 0x50,
];

class GameboyEmulator {
    // CPU instance
    private cpu = new CPU();

    // Memory instance
    private memory = new Memory();

    // Cartridge instance
    private cartridge = new Cartridge();

    // Ticks passed
    private ticks: number = 0;

    private biosSize: number = 0;

    constructor() {
        DMG_BIOS.forEach((value, index) => {
            this.memory.write8BitsValue(index, value);
        });
        this.biosSize = DMG_BIOS.length;
    }

    public loadCartridge = (cartridge: Cartridge) => {
        this.cartridge = cartridge;
        this.cartridge.getProgramData().forEach((value, index) => {
            this.memory.write8BitsValue(index + this.biosSize, value);
        });
    }

    public run = () => {
        this.tick();
    }

    private tick = () => {
        const tickCount = this.cpu.tick(this.memory);
        this.ticks += tickCount;
    }
}

export default GameboyEmulator;